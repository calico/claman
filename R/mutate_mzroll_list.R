#' Floor Peaks
#'
#' Set a minimum peak abundance of floor_value for low abundance and
#'   undetected peaks.
#'
#' @inheritParams test_mzroll_list
#' @param log2_floor_value minimum value to set for low abundance or
#'   missing peaks
#'
#' @return \code{\link{process_mzroll}}
#'
#' @examples
#' floored_peaks <- floor_peaks(nplug_mzroll_augmented, 12)
#'
#' @export
floor_peaks <- function(mzroll_list, log2_floor_value = 12) {
  # summarize peaks associated with each peakgroup

  missing_peaks <- tidyr::expand_grid(
    groupId = mzroll_list$features$groupId,
    sampleId = mzroll_list$samples$sampleId
  ) %>%
    dplyr::anti_join(mzroll_list$measurements, by = c("groupId", "sampleId")) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(log2_abundance = log2_floor_value)

  # combine detected peaks with peaks that were missing for some samples
  completed_peaks <- dplyr::bind_rows(
    mzroll_list$measurements %>%
      dplyr::mutate(log2_abundance = dplyr::case_when(
        is.na(log2_abundance) ~ log2_floor_value,
        log2_abundance < log2_floor_value ~ log2_floor_value,
        log2_abundance >= log2_floor_value ~ log2_abundance
      )),
    missing_peaks
  ) %>%
    dplyr::group_by(groupId) %>%
    dplyr::mutate(
      centered_log2_abundance = log2_abundance - mean(log2_abundance)
    ) %>%
    dplyr::ungroup()

  mzroll_list$measurements <- completed_peaks

  mzroll_list
}

#' Normalize Peaks
#'
#' @inheritParams test_mzroll_list
#' @param normalization_method Normalization method to apply
#' \itemize{
#'   \item{\code{median polish}: column normalization based on average signal}
#'   \item{\code{loading value}: column normalization using a sample-level
#'     value
#'     }
#'   \item{\code{center batches}: batch centering}
#'   \item{\code{reference sample}: compare to reference sample}
#'   \item{\code{reference condition}: compare each sample to its specified
#'     reference sample}
#'   \item{\code{loess}: weighted smoothing of IC over time (adds
#'     \code{.loess_fit} as a peaks variable in addition to
#'     \code{norm_peak_varname})}
#'   }
#' @param quant_peak_varname variable in measurements to use for abundance
#' @param norm_peak_varname variable in measurements to add for normalized
#'   abundance
#' @param ... additional arguments to pass to normalization methods
#'
#' @return a \code{mzroll_list} as generated by \code{\link{process_mzroll}}
#'   a \code{norm_peak_varname} variable added to measuremnets
#'
#' @examples
#'
#' normalize_peaks(
#'   nplug_mzroll_augmented,
#'   "median polish",
#'   quant_peak_varname = "log2_abundance",
#'   norm_peak_varname = "normalized_log2_abundance"
#' )
#' 
#' # this examples doesn't make biological sense but its syntactically correct
#' normalize_peaks(
#'   nplug_mzroll_augmented,
#'   "loading value",
#'   quant_peak_varname = "log2_abundance",
#'   norm_peak_varname = "normalized_log2_abundance",
#'   loading_varname = "DR"
#'   )
#' 
#' normalize_peaks(
#'   nplug_mzroll_augmented,
#'   "center batches",
#'   quant_peak_varname = "log2_abundance",
#'   norm_peak_varname = "normalized_log2_abundance",
#'   batch_varnames = "month",
#'   centering_fxn = median
#' )
#' 
#' normalize_peaks(
#'   nplug_mzroll_augmented,
#'   normalization_method = "reference condition",
#'   quant_peak_varname = "log2_abundance",
#'   norm_peak_varname = "normalized_log2_abundance",
#'   condition_varname = "condition",
#'   reference_varname = "reference"
#' )
#' 
#' normalize_peaks(
#'   nplug_mzroll_augmented,
#'   normalization_method = "reference sample",
#'   quant_peak_varname = "log2_abundance",
#'   norm_peak_varname = "normalized_log2_abundance",
#'   batch_varnames = c("month", "extraction"),
#'   reference_varname = "exp_ref",
#'   reference_values = "ref"
#' )
#' 
#' @export
normalize_peaks <- function(
  mzroll_list,
  normalization_method,
  quant_peak_varname = "log2_abundance",
  norm_peak_varname = "normalized_log2_IC",
  ...
  ) {
  
  dots <- list(...)
  test_mzroll_list(mzroll_list)

  checkmate::assertString(quant_peak_varname)
  if (!(quant_peak_varname %in% colnames(mzroll_list$measurements))) {
    stop(
      "\"quant_peak_varname\":",
      quant_peak_varname,
      ", not present in measurements table"
    )
  }
  checkmate::assertString(norm_peak_varname)

  normalization_methods <- tibble::tribble(
    ~method_name, ~function_name,
    "median polish", "normalize_peaks.median_polish",
    "loading value", "normalize_peaks.loading_value",
    "center batches", "normalize_peaks.batch_center",
    "reference sample", "normalize_peaks.reference_sample",
    "reference condition", "normalize_peaks.reference_condition",
    "loess", "normalize_peaks.loess"
  )

  checkmate::assertChoice(
    normalization_method,
    normalization_methods$method_name
  )

  normalization_method_call <- normalization_methods$function_name[
    normalization_methods$method_name == normalization_method
  ]

  method_args <- dots[intersect(
    names(dots),
    names(formals(normalization_method_call))
  )]
  
  unused_args <- setdiff(names(dots), names(formals(normalization_method_call)))
  if (length(unused_args) > 0) {
    warning(glue::glue(
      "{length(unused_args)} passed arguments could not be used by
       {normalization_method_call}: {paste(unused_args, collapse = ', ')} ")
      )
  }

  normalization_output <- do.call(
    normalization_method_call,
    append(
      list(
        mzroll_list = mzroll_list,
        quant_peak_varname = quant_peak_varname,
        norm_peak_varname = norm_peak_varname
      ),
      method_args
    )
  )

  normalization_output
}

#' Normalize Peaks - Median Polish
#' 
#' Using a robust metabolomics normalization rescale ion counts based on the
#'   consensus signal of each sample.
#'
#' @details The robust median polish was reported in Kamphorst et al. 2015, see
#'   \url{https://github.com/shackett/Pancreatic_tumor_metabolomics}.
#'
#' @inheritParams normalize_peaks
#' @inheritParams floor_peaks
#'
#' @rdname normalize_peaks
normalize_peaks.median_polish <- function(
  mzroll_list,
  quant_peak_varname,
  norm_peak_varname,
  log2_floor_value = NA
  ) {
  
  stopifnot(length(log2_floor_value) == 1)
  if (!is.na(log2_floor_value)) {
    stopifnot(class(log2_floor_value) == "numeric")

    normalization_peaks <- mzroll_list$measurements %>%
      dplyr::filter(
        !!rlang::sym(quant_peak_varname) > log2_floor_value + 0.001
      )
  } else {
    normalization_peaks <- mzroll_list$measurements
  }

  if (any(is.na(mzroll_list$measurements[[quant_peak_varname]]))) {
    stop(
      "NAs are not allowed in ",
      quant_peak_varname,
      " try calling floor_peaks() first"
    )
  }

  sample_scaling_factors <- normalization_peaks %>%
    dplyr::group_by(groupId) %>%
    dplyr::mutate(
      median_abund = stats::median(!!rlang::sym(quant_peak_varname))
    ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(
      diff_to_median = !!rlang::sym(quant_peak_varname) - median_abund
    ) %>%
    dplyr::group_by(sampleId) %>%
    dplyr::summarize(scaling_factor = stats::median(diff_to_median))

  missing_sample_scaling_factors <- mzroll_list$samples %>%
    dplyr::anti_join(sample_scaling_factors, by = "sampleId")

  if (nrow(missing_sample_scaling_factors) != 0) {
    stop(
      "sample scaling factors could not be calculated for ",
      nrow(missing_sample_scaling_factors),
      " samples"
    )
  }

  if (!is.na(log2_floor_value)) {
    updated_measurements <- mzroll_list$measurements %>%
      dplyr::filter(
        !!rlang::sym(quant_peak_varname) > log2_floor_value + 0.001
      ) %>%
      dplyr::left_join(sample_scaling_factors, by = "sampleId") %>%
      dplyr::mutate(
        !!rlang::sym(norm_peak_varname) :=
          !!rlang::sym(quant_peak_varname) - scaling_factor
      ) %>%
      # measurements starting at limit of detection are reset to
      #   log2_floor_value
      dplyr::bind_rows(
        mzroll_list$measurements %>%
          dplyr::filter(
            !!rlang::sym(quant_peak_varname) <= log2_floor_value + 0.001
          ) %>%
          dplyr::mutate(!!rlang::sym(norm_peak_varname) := log2_floor_value)
      ) %>%
      dplyr::select(-scaling_factor) %>%
      # measurements pushed below limit of detection are reset to
      #   log2_floor_value
      dplyr::mutate(
        !!rlang::sym(norm_peak_varname) :=
          pmax(!!rlang::sym(norm_peak_varname), log2_floor_value)
      )
  } else {
    updated_measurements <- mzroll_list$measurements %>%
      dplyr::left_join(sample_scaling_factors, by = "sampleId") %>%
      dplyr::mutate(
        !!rlang::sym(norm_peak_varname) :=
          !!rlang::sym(quant_peak_varname) - scaling_factor
      ) %>%
      dplyr::select(-scaling_factor)
  }

  mzroll_list <- romic::update_tomic(mzroll_list, updated_measurements)
  
  return(mzroll_list)
}


#' Normalize Peaks - Loading Value
#' 
#' Using a sample-level summary, such as number of cells, adjust all values. 
#' 
#' @details Note, log2 intensities will be shifted down by this value, so
#'   make sure the provided values are appropriately transformed.
#'
#' @inheritParams normalize_peaks
#' @inheritParams floor_peaks
#' @param loading_varname sample variable used for adjustment
#'
#' @rdname normalize_peaks
normalize_peaks.loading_value <- function(
  mzroll_list,
  quant_peak_varname,
  norm_peak_varname,
  loading_varname,
  log2_floor_value = NA
) {
  
  stopifnot(length(log2_floor_value) == 1)
  if (!is.na(log2_floor_value)) {
    stopifnot(class(log2_floor_value) == "numeric")
    
    normalization_peaks <- mzroll_list$measurements %>%
      dplyr::filter(
        !!rlang::sym(quant_peak_varname) > log2_floor_value + 0.001
      )
  } else {
    normalization_peaks <- mzroll_list$measurements
  }
  
  if (any(is.na(mzroll_list$measurements[[quant_peak_varname]]))) {
    stop(
      "NAs are not allowed in ",
      quant_peak_varname,
      " try calling floor_peaks() first"
    )
  }
  
  # validate loading_varname
  
  checkmate::assertChoice(loading_varname, mzroll_list$design$samples$variable)
  
  loading_values <- mzroll_list$samples %>%
    dplyr::select("sampleId", scaling_factor = !!rlang::sym(loading_varname))
  
  checkmate::assertNumeric(
    loading_values$scaling_factor,
    any.missing = FALSE,
    finite = TRUE
    )
  
  if (!is.na(log2_floor_value)) {
    updated_measurements <- mzroll_list$measurements %>%
      dplyr::filter(
        !!rlang::sym(quant_peak_varname) > log2_floor_value + 0.001
      ) %>%
      dplyr::left_join(loading_values, by = "sampleId") %>%
      dplyr::mutate(
        !!rlang::sym(norm_peak_varname) :=
          !!rlang::sym(quant_peak_varname) - scaling_factor
      ) %>%
      # measurements starting at limit of detection are reset to
      #   log2_floor_value
      dplyr::bind_rows(
        mzroll_list$measurements %>%
          dplyr::filter(
            !!rlang::sym(quant_peak_varname) <= log2_floor_value + 0.001
          ) %>%
          dplyr::mutate(!!rlang::sym(norm_peak_varname) := log2_floor_value)
      ) %>%
      dplyr::select(-scaling_factor) %>%
      # measurements pushed below limit of detection are reset to
      #   log2_floor_value
      dplyr::mutate(
        !!rlang::sym(norm_peak_varname) :=
          pmax(!!rlang::sym(norm_peak_varname), log2_floor_value)
      )
  } else {
    updated_measurements <- mzroll_list$measurements %>%
      dplyr::left_join(loading_values, by = "sampleId") %>%
      dplyr::mutate(
        !!rlang::sym(norm_peak_varname) :=
          !!rlang::sym(quant_peak_varname) - scaling_factor
      ) %>%
      dplyr::select(-scaling_factor)
  }
  
  mzroll_list <- romic::update_tomic(mzroll_list, updated_measurements)
  
  return(mzroll_list)
}

#' Normalize Peaks - Batch Center
#' 
#' @inheritParams normalize_peaks
#' @inheritParams floor_peaks
#' @param batch_varnames variables to use for grouping when removing batch
#'   effects
#' @param centering_fxn function to use when centering (mean, median, ...)
#'
#' @rdname normalize_peaks
normalize_peaks.batch_center <- function(
  mzroll_list,
  quant_peak_varname,
  norm_peak_varname,
  batch_varnames,
  log2_floor_value = NA,
  centering_fxn = mean
  ) {
  checkmate::assertChoice(batch_varnames, colnames(mzroll_list$samples))
  stopifnot(length(log2_floor_value) == 1)
  if (!is.na(log2_floor_value)) {
    stopifnot(class(log2_floor_value) == "numeric")
  }
  checkmate::assertFunction(centering_fxn)

  centered_peaks <- mzroll_list$measurements %>%
    dplyr::left_join(mzroll_list$samples %>%
      dplyr::select(sampleId, !!!rlang::syms(batch_varnames)),
    by = "sampleId"
    ) %>%
    dplyr::group_by(groupId, !!!rlang::syms(batch_varnames)) %>%
    dplyr::mutate(
      .center = centering_fxn(!!rlang::sym(quant_peak_varname))
    ) %>%
    dplyr::group_by(groupId) %>%
    dplyr::mutate(
      .group_center = centering_fxn(!!rlang::sym(quant_peak_varname))
    ) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(
      !!rlang::sym(norm_peak_varname) :=
        !!rlang::sym(quant_peak_varname) - (.center - .group_center)
    ) %>%
    dplyr::select(
      !!!rlang::syms(c(colnames(mzroll_list$measurements), norm_peak_varname))
    )

  centered_refloor <- normalization_refloor(
    centered_peaks,
    log2_floor_value,
    norm_peak_varname,
    quant_peak_varname
  )

  mzroll_list <- romic::update_tomic(mzroll_list, centered_refloor)
  
  return(mzroll_list)
}

#' Normalize Peaks - Reference Sample
#' 
#' Compare each sample to the reference samples within the same batch
#'
#' @inheritParams normalize_peaks.batch_center
#' @param reference_varname variable specifying which samples are references
#' @param reference_values values of \code{reference_varname} indicating
#'   reference samples
#'
#' @rdname normalize_peaks
normalize_peaks.reference_sample <- function(
  mzroll_list,
  quant_peak_varname,
  norm_peak_varname,
  batch_varnames,
  reference_varname = "sample",
  reference_values = "posctl",
  log2_floor_value = NA
  ) {
  
  purrr::walk(
    batch_varnames,
    checkmate::assertChoice,
    colnames(mzroll_list$samples)
    )
  checkmate::assertChoice(reference_varname, colnames(mzroll_list$samples))
  checkmate::assertCharacter(reference_values)

  stopifnot(length(log2_floor_value) == 1)
  if (!is.na(log2_floor_value)) {
    stopifnot(class(log2_floor_value) == "numeric")
  }

  annotated_peaks <- mzroll_list$measurements %>%
    dplyr::left_join(mzroll_list$samples %>%
      dplyr::select(
        sampleId,
        !!!rlang::syms(c(batch_varnames, reference_varname))
      ),
    by = "sampleId"
    )

  reference_peaks <- annotated_peaks %>%
    dplyr::filter(
      !!rlang::quo(!!rlang::sym(reference_varname) %in% reference_values)
    ) %>%
    dplyr::group_by(groupId, !!!rlang::syms(batch_varnames)) %>%
    dplyr::summarize(
      .reference = median(!!rlang::sym(quant_peak_varname)),
      .groups = "drop"
      )

  if (is.na(log2_floor_value)) {
    # use the relative scale
    reference_peaks <- reference_peaks %>%
      dplyr::mutate(.reference_diff = .reference)
  } else {
    # retain the original scale
    reference_peaks <- reference_peaks %>%
      dplyr::group_by(groupId) %>%
      dplyr::mutate(.reference_diff = .reference - mean(.reference)) %>%
      dplyr::ungroup()
  }
  
  normalized_peaks <- annotated_peaks %>%
    dplyr::left_join(reference_peaks, by = c("groupId", batch_varnames)) %>%
    dplyr::mutate(
      !!rlang::sym(norm_peak_varname) :=
        !!rlang::sym(quant_peak_varname) - .reference_diff
    ) %>%
    dplyr::select(
      !!!rlang::syms(c(colnames(mzroll_list$measurements), norm_peak_varname))
    )

  # ensure that normalized values still respect the limit of detection
  reference_refloor <- normalization_refloor(
    normalized_peaks,
    log2_floor_value,
    norm_peak_varname,
    quant_peak_varname
  )

  mzroll_list <- romic::update_tomic(mzroll_list, reference_refloor)

  return(mzroll_list)
}

#' Normalize Peaks - Reference Condition
#' 
#' Compare each sample to the reference samples within the same batch
#'
#' @inheritParams normalize_peaks.batch_center
#' @param condition_varname variable specifying each sample's condition
#' @inheritParams normalize_peaks.reference_sample
#'
#' @details
#' reference_varname specifies which condition to contrast a given sample to
#'   (using the condition values from condition_varname)
#'
#' @rdname normalize_peaks
normalize_peaks.reference_condition <- function(
  mzroll_list,
  quant_peak_varname,
  norm_peak_varname,
  condition_varname = "condition #",
  reference_varname = "reference condition #",
  log2_floor_value = NA
  ) {

  # check for valid inputs

  checkmate::assertString(condition_varname)
  if (!(condition_varname %in% colnames(mzroll_list$samples))) {
    stop(
      "\"reference_varname\":",
      condition_varname,
      ", not present in samples table"
    )
  }

  checkmate::assertString(reference_varname)
  if (!(reference_varname %in% colnames(mzroll_list$samples))) {
    stop(
      "\"reference_varname\":",
      reference_varname,
      ", not present in samples table"
    )
  }

  # check for reference mis-specification

  if (!(
    all(mzroll_list$samples[[reference_varname]] != "") &&
      length(mzroll_list$samples[[reference_varname]]) ==
        nrow(mzroll_list$samples)
  )) {
    stop("not all samples possessed a reference condition")
  }

  missing_references <- setdiff(
    unique(mzroll_list$samples[[reference_varname]]),
    mzroll_list$samples[[condition_varname]]
  )
  if (length(missing_references) != 0) {
    stop(
      length(missing_references),
      " reference conditions were not present as conditions: ",
      paste(missing_references, collapse = ", ")
    )
  }

  stopifnot(length(log2_floor_value) == 1)
  if (!is.na(log2_floor_value)) {
    stopifnot(class(log2_floor_value) == "numeric")
  }
  
  # summarize reference conditions

  annotated_peaks <- mzroll_list$measurements %>%
    dplyr::left_join(mzroll_list$samples %>%
      dplyr::select(
        sampleId,
        !!!rlang::syms(c(condition_varname, reference_varname))
      ),
    by = "sampleId"
    )

  # estimate log abundance for each reference condition per group
  reference_peaks <- annotated_peaks %>%
    dplyr::filter(
      !!rlang::sym(condition_varname) %in%
        unique(mzroll_list$samples[[reference_varname]])
    ) %>%
    dplyr::group_by(groupId, !!rlang::sym(condition_varname)) %>%
    dplyr::summarize(
      .reference = median(!!rlang::sym(quant_peak_varname)),
      .groups = "drop"
      ) %>%
    dplyr::ungroup()

  if (is.na(log2_floor_value)) {
    # use the relative scale
    reference_peaks <- reference_peaks %>%
      dplyr::mutate(.reference_diff = .reference)
  } else {
    # retain the original scale
    reference_peaks <- reference_peaks %>%
      dplyr::group_by(groupId) %>%
      dplyr::mutate(.reference_diff = .reference - mean(.reference)) %>%
      dplyr::ungroup()
  }
  
  join_by <- rlang::set_names(
    rlang::quo_name(condition_varname),
    rlang::quo_name(reference_varname)
  )

  normalized_peaks <- annotated_peaks %>%
    # add reference to each peak
    dplyr::left_join(reference_peaks, by = c("groupId", join_by)) %>%
    dplyr::mutate(
      !!rlang::sym(norm_peak_varname) :=
        !!rlang::sym(quant_peak_varname) - .reference_diff
    ) %>%
    dplyr::select(
      !!!rlang::syms(c(colnames(mzroll_list$measurements), norm_peak_varname))
    )

  # ensure that normalized values still respect the limit of detection
  reference_refloor <- normalization_refloor(
    normalized_peaks,
    log2_floor_value,
    norm_peak_varname,
    quant_peak_varname
  )
  
  mzroll_list <- romic::update_tomic(mzroll_list, reference_refloor)

  return(mzroll_list)
}

#' @inheritParams normalize_peaks.batch_center
#' @param weights_tribble a table containing weights and sample variables to
#'   match them to.
#'
#' @rdname normalize_peaks
normalize_peaks.loess <- function(
  mzroll_list,
  quant_peak_varname,
  norm_peak_varname,
  weights_tribble = NULL,
  log2_floor_value = 12
  ) {
  stopifnot("datetime" %in% colnames(mzroll_list$samples))

  stopifnot(length(log2_floor_value) == 1)
  if (!is.na(log2_floor_value)) {
    stopifnot(class(log2_floor_value) == "numeric")
  }

  if (!is.null(weights_tribble)) {
    # check weights_tribble validity
    stopifnot("data.frame" %in% class(weights_tribble))
    stopifnot("weights" %in% colnames(weights_tribble))

    weights_vars <- setdiff(colnames(weights_tribble), "weights")
    stopifnot(weights_vars %in% colnames(mzroll_list$samples))
    stopifnot(length(weights_vars) >= 1)

    sample_weights <- mzroll_list$samples %>%
      dplyr::inner_join(weights_tribble, by = weights_vars) %>%
      dplyr::select(sampleId, datetime, weights)

    if (nrow(sample_weights) == 0) {
      stop(
        "No samples with weights exist
      check configuration of \"weights_tribble\""
      )
    }
  } else {
    sample_weights <- mzroll_list$samples %>%
      dplyr::select(sampleId, datetime) %>%
      dplyr::mutate(weights = 1)
  }

  loess_fits <- mzroll_list$measurements %>%
    dplyr::left_join(sample_weights, by = "sampleId") %>%
    tidyr::nest(groupData = -groupId) %>%
    dplyr::mutate(loess_fits = purrr::map(
      groupData,
      fit_loess,
      quant_peak_varname = quant_peak_varname,
      norm_peak_varname = norm_peak_varname
    )) %>%
    dplyr::select(-groupData) %>%
    tidyr::unnest(loess_fits) %>%
    dplyr::select(!!!rlang::syms(c(
      colnames(mzroll_list$measurements),
      ".loess_fit", norm_peak_varname
    )))

  loess_floor <- normalization_refloor(
    loess_fits,
    log2_floor_value,
    norm_peak_varname,
    quant_peak_varname
  )

  mzroll_list <- romic::update_tomic(mzroll_list, loess_floor)
  
  return(mzroll_list)
}

fit_loess <- function(groupData, quant_peak_varname, norm_peak_varname) {
  loess_data <- groupData %>%
    dplyr::arrange(datetime) %>%
    dplyr::mutate(
      hours_elapsed = lubridate::interval(datetime[1], datetime) /
        lubridate::hours(1)
    )

  # weights should be inversely proportional to variance

  loess_model <- stats::loess(
    formula = stats::as.formula(
      glue::glue("{quant_peak_varname} ~ hours_elapsed")
      ),
    data = loess_data,
    weights = weights
  )

  loess_apply <- loess_data %>%
    dplyr::mutate(
      .loess_fit = stats::predict(loess_model),
      .loess_shift = .loess_fit - mean(.loess_fit),
      !!rlang::sym(norm_peak_varname) :=
        !!rlang::sym(quant_peak_varname) - .loess_shift
    ) %>%
    dplyr::select(!!!rlang::syms(c(
      colnames(groupData),
      ".loess_fit",
      norm_peak_varname
    )))

  return(loess_apply)
}

normalization_refloor <- function(
  normalized_peaks,
  log2_floor_value,
  norm_peak_varname,
  quant_peak_varname
  ) {

  # If a floor value is supplied floor a peak to this value if it reached the
  # floor either pre- or post-normalization

  stopifnot(length(log2_floor_value) == 1)
  if (!is.na(log2_floor_value)) {
    # peaks starting or pushed below limit of detection are reset to
    # log2_floor_value
    stopifnot(class(log2_floor_value) == "numeric")

    normalized_peaks <- normalized_peaks %>%
      dplyr::mutate(!!rlang::sym(norm_peak_varname) := dplyr::case_when(
        !!rlang::sym(quant_peak_varname) <=
          log2_floor_value + 0.001 ~ log2_floor_value,
        !!rlang::sym(norm_peak_varname) <=
          log2_floor_value + 0.001 ~ log2_floor_value,
        TRUE ~ !!rlang::sym(norm_peak_varname)
      ))
  }

  return(normalized_peaks)
}
