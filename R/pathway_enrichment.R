#' Pathway Enrichments
#'
#' @inheritParams test_mzroll_list
#' @param significance returned by \code{\link{diffex_mzroll}}; a tibble of
#'   tests performed.
#' @inheritParams process_mzroll
#' @param test_absolute_effects If TRUE then only consider the magnitude of
#'   test-statistics when calculating rankings for enrichment; if FALSE then
#'   consider sign as well.
#'
#' @return a list containing:
#' \itemize{
#'   \item{enrichment_table: a tibble containing each term's enrichment for
#'     every pathway and an enrichment_plot}
#'   \item{enrichment_plots: pre-generated plots containing the most
#'     significant enrichments for each term}
#'   }
#'
#' @export
pathway_enrichments <- function(mzroll_list,
                                significance,
                                standard_databases,
                                test_absolute_effects = TRUE) {
  test_mzroll_list(mzroll_list)

  if (!("data.frame" %in% class(significance))) {
    stop(
      "\"significance\" must be a table of tests performed
      as generated by diffex_mzroll()"
    )
  }

  if (!("list" %in% class(standard_databases))) {
    stop(
      "\"standard_databases\" must be a list as generated
        by configure_db_access()"
    )
  }

  checkmate::assertLogical(test_absolute_effects, 1)

  # find all compound annotations
  systematic_compounds <- query_systematic_compounds(
    systematic_compounds_con = standard_databases$systematic_compounds_con
  )

  # format pathways as a list containing the metabolite members
  pathway_nest <- mzroll_list$peakgroups %>%
    dplyr::filter(!is.na(systematicCompoundId)) %>%
    dplyr::inner_join(
      systematic_compounds$metabolic_pathways,
      by = "systematicCompoundId"
    ) %>%
    dplyr::select(
      groupId,
      systematicCompoundId,
      compoundName,
      databaseId,
      pathwayId,
      pathwayName
    ) %>%
    tidyr::nest(pathway_entries = c(-pathwayId, -pathwayName)) %>%
    dplyr::filter(purrr::map_int(pathway_entries, nrow) >= 4)

  pathway_list <- purrr::map(
    pathway_nest$pathway_entries,
    function(x) {
      as.character(x$groupId)
    }
  )
  names(pathway_list) <- pathway_nest$pathwayName

  if (test_absolute_effects) {
    significance <- significance %>%
      dplyr::mutate(statistic = abs(statistic))
  }

  enrichment_by_term <- mzroll_list$peakgroups %>%
    dplyr::filter(!is.na(systematicCompoundId)) %>%
    dplyr::inner_join(significance, by = "groupId") %>%
    tidyr::nest(term_data = -term) %>%
    dplyr::mutate(gsea_results = purrr::map(
      term_data,
      calculate_pathway_enrichment,
      pathway_list
    )) %>%
    dplyr::select(-term_data) %>%
    tidyr::unnest_wider(gsea_results)

  enrichment_table_grobs <- enrichment_by_term %>%
    dplyr::select(-fgsea_results) %>%
    tidyr::unnest(gsea_table_grob)

  term_plots <- enrichment_table_grobs$gsea_table_grob
  names(term_plots) <- enrichment_table_grobs$term

  enrichment_table <- enrichment_by_term %>%
    dplyr::select(-gsea_table_grob) %>%
    tidyr::unnest(fgsea_results) %>%
    dplyr::select(-leadingEdge)

  # Issue 569: add back peak group and compound data, removed by fgsea::fgsea()
  enrichment_table_full <- dplyr::inner_join(
    enrichment_table,
    pathway_nest,
    by = c("pathway" = "pathwayName")
  ) %>%
    dplyr::select(
      term,
      pathwayId,
      pathway,
      pathway_entries,
      pval,
      padj,
      ES,
      NES,
      nMoreExtreme,
      size,
      enrichment_plot
    )

  enrichment_table_full_expanded <- enrichment_table_full %>%
    tidyr::unnest(cols = c(pathway_entries))

  pathway_enrichments_output <- list(
    enrichment_table = enrichment_table_full,
    enrichment_table_expanded = enrichment_table_full_expanded,
    enrichment_plots = term_plots
  )

  pathway_enrichments_output
}

#' Calculate Pathway Enrichments
#'
#' @param term_data test statistics for a single term
#' @param pathway_list a named list formatted for fgsea with a name
#'   corresponding to a pathway and entries matching the analytes included
#'   in the set.
#' @param padj_cutoff minimum adjusted p-value to use for creating a the
#'   pathway summary plot.
#'
#' @return a list containing a summary plot for the term and tibble
#'   containing data and plots for all comparisons performed.
calculate_pathway_enrichment <- function(term_data,
                                         pathway_list,
                                         padj_cutoff = 0.2) {
  stopifnot(
    "numeric" %in% class(padj_cutoff),
    length(padj_cutoff) == 1,
    padj_cutoff > 0,
    padj_cutoff <= 1
  )

  ranked_coefs <- term_data$statistic
  names(ranked_coefs) <- as.character(term_data$groupId)

  sorted_ranked_coefs <- sort(ranked_coefs, decreasing = TRUE)

  fgsea_results <- fgsea::fgsea(
    pathway_list,
    sorted_ranked_coefs,
    nperm = 10000
  )
  # generate an enrichment plot for each pathway
  fgsea_results$enrichment_plot <- purrr::map(
    pathway_list,
    fgsea::plotEnrichment,
    ranked_coefs
  )

  # generate a plot summarizing the largest pathway changes
  gsea_table_grob <- fgsea::plotGseaTable(
    pathway_list[fgsea_results$padj < padj_cutoff],
    ranked_coefs,
    fgsea_results,
    gseaParam = 0.5,
    render = FALSE
  )

  list(
    fgsea_results = fgsea_results,
    gsea_table_grob = list(plot = gsea_table_grob)
  )
}
